<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>再谈LruCache | Septenary Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">再谈LruCache</h1><a id="logo" href="/.">Septenary Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">再谈LruCache</h1><div class="post-meta">Jun 8, 2015<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><div class="post-content"><p><strong>LRU</strong>算法是一种很常用的内存管理方式，为实现该算法，有两方面要做：</p>
<ol>
<li><p><strong>实现最近使用：</strong><br>可以用链表完成，在使用链表时将最近索引到的元素从当前位置移除然后放置在链表头部，这样最久未使用的就被逐渐移到了链表尾部</p>
</li>
<li><p><strong>实现快速检索:</strong><br>想要快速的检索到对应元素可以 通过哈希表完成,通过key值查找到对应的value</p>
</li>
</ol>
<p>其实 JDK 中强大的 <strong>Collection</strong> 已经向我们提供了 <code>LinkedHashMap</code> 满足以上两种需求。</p>
<a id="more"></a>
<h3 id="LruCache-的使用"><a href="#LruCache-的使用" class="headerlink" title="LruCache 的使用"></a>LruCache 的使用</h3><p>Anroid中对内存的管理，在早期有一种较为常见的缓存实现，用 <strong>软引用</strong> 或 <strong>弱引用</strong> (  <code>SoftReference</code> or <code>WeakReference</code> )存储在 <code>Map</code> 中，然而在 <strong>API 9</strong> 之后，<strong>Dalvik</strong> 的内存回收机制做了改变，非强引用的对象很容易被GC清理。</p>
<p><code>LruCache</code> 则顺势而生，它的使用场景大部分都是缓存 <code>Bimtap</code> 时用到的，（用以保证内存合理、有效的使用），下面是 <code>LruCache</code> 的简单使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化LruCache</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initCache</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 系统可用内存的1/4</span></span><br><span class="line">    <span class="keyword">int</span> memClass = ((ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE)).getMemoryClass();</span><br><span class="line">    <span class="keyword">int</span> cacheSize = <span class="number">1024</span> * <span class="number">1024</span> * memClass / <span class="number">4</span>;</span><br><span class="line">    mCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 一张位图所占内存大小</span></span><br><span class="line">            <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">entryRemoved</span><span class="params">(<span class="keyword">boolean</span> evicted, String key, Bitmap oldValue, Bitmap newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.entryRemoved(evicted, key, oldValue, newValue);</span><br><span class="line">        <span class="comment">// 回收最久未使用的bitmap</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldValue.recycle();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putBitmap</span><span class="params">(String key,Bitmap bmp)</span></span>&#123;</span><br><span class="line">    mCache.put(key,bitmap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">getBitmap</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    Bitmap bmp = mCache.get(key);</span><br><span class="line">    <span class="keyword">return</span> bmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LrcCache-简单分析"><a href="#LrcCache-简单分析" class="headerlink" title="LrcCache 简单分析"></a>LrcCache 简单分析</h3><p>接下来介绍下 <code>LruCache</code> 的几段重要代码<br><code>LruCache</code> 的构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    <span class="comment">// 初始化一个LinkedHashMap实例，所有元素都存在这个map中</span></span><br><span class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造器中实际上初始化了一个 <code>LinkedHashMap</code> ，接下来所有元素操作(存储和索引)都是基于该 map 进行的</p>
<p>我们再来看下LruCache的</p>
<ul>
<li>get方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    V mapValue;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 从map中获取元素   </span></span><br><span class="line">        mapValue = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hitCount++;</span><br><span class="line">            <span class="keyword">return</span> mapValue;</span><br><span class="line">        &#125;</span><br><span class="line">         missCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未命中尝试创建一个value</span></span><br><span class="line">    V createdValue = create(key);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 添加到map中</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            createCount++;</span><br><span class="line">            mapValue = map.put(key, createdValue);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>put方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    V previous;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        putCount++;</span><br><span class="line">        size += safeSizeOf(key, value);</span><br><span class="line">        previous = map.put(key, value);</span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">            size -= safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">    <span class="comment">// 重新计算内存占用情况</span></span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">    <span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其中<code>trimToSize(maxSize)</code>这个方法实现了内存大小的控制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新计算集合元素大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 从map中取得最久未被使用的元素</span></span><br><span class="line">            Map.Entry&lt;K, V&gt; toEvict = map.eldest();</span><br><span class="line">            ......</span><br><span class="line">            key = toEvict.getKey();</span><br><span class="line">            <span class="comment">//从map中移除，并重新计算总大小，直到小余maxSize为止</span></span><br><span class="line">            map.remove(key);</span><br><span class="line">            size -= safeSizeOf(key, value);</span><br><span class="line">            ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么问题来了，为什么 执行 <code>get</code> 的时候 <strong>map</strong> 中的元素就被重新排列了， <strong>eldest</strong> 元素又是如何给出的呢， 原因都在 <code>LinkedHashMap</code> </p>
<h3 id="LruCache-的发动机"><a href="#LruCache-的发动机" class="headerlink" title="LruCache 的发动机"></a>LruCache 的发动机</h3><p><code>LinkedHashMap</code> 实现了 <strong>LRU算法</strong> ， 它是在 <code>LruCache</code> 的构造器中初始化的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>所有数据都存储在这个 <strong>map</strong> 中<br>注意初始化  <code>LinkedHashMap</code> 的第三个参数 <code>accessOrder</code> </p>
<ul>
<li><em>true</em>  随机访问重新排序</li>
<li><em>false</em>  插入元素时重新排序</li>
</ul>
<p>它决定了如何 控制 <strong>map</strong> 的 <strong>ordering</strong></p>
<p>在来看下LinkedHashMap的源码，其中声明了一个常量 <strong>header</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ **</span><br><span class="line">* A dummy entry in the circular linked list of entries in the map.</span><br><span class="line">* The first real entry is header.nxt, and the last is header.prv.</span><br><span class="line">* If the map is empty, header.nxt == header &amp;&amp; header.prv == header.</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">transient</span> LinkedEntry&lt;K, V&gt; header;</span><br></pre></td></tr></table></figure>
<p>这个header记录了链表的首位元素</p>
<p>我们看下对 <strong>map</strong> 进行操作的几个方法</p>
<ul>
<li>添加元素时，<strong>relink</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNewEntry</span><span class="params">(K key, V value, <span class="keyword">int</span> hash, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        LinkedEntry&lt;K, V&gt; header = <span class="keyword">this</span>.header;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 对header首尾元素的指针重新指向</span></span><br><span class="line">        LinkedEntry&lt;K, V&gt; oldTail = header.prv;</span><br><span class="line">        LinkedEntry&lt;K, V&gt; newTail = <span class="keyword">new</span> LinkedEntry&lt;K,V&gt;(</span><br><span class="line">                key, value, hash, table[index], header, oldTail);</span><br><span class="line">        table[index] = oldTail.nxt = header.prv = newTail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除元素时，<strong>relink</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">postRemove</span><span class="params">(HashMapEntry&lt;K, V&gt; e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对header首尾元素的指针重新指向</span></span><br><span class="line">        LinkedEntry&lt;K, V&gt; le = (LinkedEntry&lt;K, V&gt;) e;</span><br><span class="line">        le.prv.nxt = le.nxt;</span><br><span class="line">        le.nxt.prv = le.prv;</span><br><span class="line">        le.nxt = le.prv = <span class="keyword">null</span>; <span class="comment">// Help the GC (for performance)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>访问元素, <code>accessOrder</code> 判断是否调用 <code>makeTail()</code> 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> hash = secondaryHash(key);</span><br><span class="line">        HashMapEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (HashMapEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - <span class="number">1</span>)];</span><br><span class="line">                e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K eKey = e.key;</span><br><span class="line">            <span class="keyword">if</span> (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (accessOrder)</span><br><span class="line">                    makeTail((LinkedEntry&lt;K, V&gt;) e);</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>就是这个 <code>makeTail()</code> 方法控制了从 <strong>map</strong> 中访问数据时 <code>header</code> 的指针 被重置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">/ **</span><br><span class="line">  * Relinks the given entry to the tail of the list. Under access ordering,</span><br><span class="line">  * <span class="keyword">this</span> method is invoked whenever the value of a  pre-existing entry is</span><br><span class="line">  * read by Map.get or modified by Map.put.</span><br><span class="line">  */</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeTail</span><span class="params">(LinkedEntry&lt;K, V&gt; e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Unlink e</span></span><br><span class="line">        e.prv.nxt = e.nxt;</span><br><span class="line">        e.nxt.prv = e.prv;</span><br><span class="line">        <span class="comment">// Relink e as tail</span></span><br><span class="line">        LinkedEntry&lt;K, V&gt; header = <span class="keyword">this</span>.header;</span><br><span class="line">        LinkedEntry&lt;K, V&gt; oldTail = header.prv;</span><br><span class="line">        e.nxt = header;</span><br><span class="line">        e.prv = oldTail;</span><br><span class="line">        oldTail.nxt = header.prv = e;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对 <strong>map</strong> 的所有操作都会改变 <code>header</code> 的指针，这样我们就可以知道 <strong>eldest</strong> 的那个元素是谁了, 这也证明了 <code>LruCache</code> 的 <strong>LRU</strong> 算法实现 由 <code>LinkedHashMap</code> 完成</p>
</div><div class="tags"><a href="/tags/LruCache/">LruCache</a></div><div class="post-nav"><a class="pre" href="/2015/06/20/bit-operation-in-android/">位运算的巧妙应用</a><a class="next" href="/2014/12/12/onclick-in-android/">android:onClick 怎样做到监听点击事件的</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'b9c9fa93919f96a68da2',
  clientSecret: 'a6f794fb428cf3622e117143d47e3dc9950b937f',
  repo: 'blog-comment',
  owner: 'ryfthink',
  admin: ['ryfthink'],
  distractionFreeMode: false,
  id: location.pathname
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Chore/">Chore</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RN/">RN</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/devOps/">devOps</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/github/">github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/它山之石/">它山之石</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/ELK/" style="font-size: 15px;">ELK</a> <a href="/tags/App-init/" style="font-size: 15px;">App init</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/CNAME/" style="font-size: 15px;">CNAME</a> <a href="/tags/Package-Manager/" style="font-size: 15px;">Package Manager</a> <a href="/tags/Package-Installer/" style="font-size: 15px;">Package Installer</a> <a href="/tags/LruCache/" style="font-size: 15px;">LruCache</a> <a href="/tags/devOps/" style="font-size: 15px;">devOps</a> <a href="/tags/cli/" style="font-size: 15px;">cli</a> <a href="/tags/uinput/" style="font-size: 15px;">uinput</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/18/pub-clipkg-npm-repo/">Publishing cli-package to npm repository</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/25/react-native-tutorial/">ReactNative Tutorial</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/logstash-mapping-config/">Logstash Mapping 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/elasticsearch-delete-indices-period/">ElasticSearch 定期删除过期索引</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/16/logstash-pipeline-config/">Logstash Pipeline 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/05/node-login-module/">mean.septenary.cn 搭建之登录逻辑梳理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/24/logstash-intergration-aliyun-oss-plugin/">Logstash 集成 aliyun/oss 插件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/17/filebeats-in-logstash/">Logstash 之 filebeats</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/16/how-to-intergration-logstash-plugin-2/">Logstash 插件集成</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/14/how-to-intergration-logstash-plugin-1/">Logstash 插件集成(简易版)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://mean.septenary.cn" title="MEAN栈博客" target="_blank">MEAN栈博客</a><ul></ul><a href="https://www.jianshu.com/u/af0f90bf5ff5" title="馒头映像" target="_blank">馒头映像</a><ul></ul><a href="https://ryfthink.github.io/azhong/" title="AZhongArtist" target="_blank">AZhongArtist</a><ul></ul><a href="https://www.jianshu.com/u/67eb55a34561" title="剑老湿" target="_blank">剑老湿</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Septenary Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>